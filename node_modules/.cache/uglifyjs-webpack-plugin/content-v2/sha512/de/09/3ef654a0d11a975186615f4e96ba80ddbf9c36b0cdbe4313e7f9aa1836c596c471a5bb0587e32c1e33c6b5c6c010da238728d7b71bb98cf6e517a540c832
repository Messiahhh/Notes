{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{64:function(t,n,a){\"use strict\";a.r(n);var e=a(0),p=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,n=t.$createElement,a=t._self._c||n;return a(\"div\",{staticClass:\"content\"},[a(\"h2\",{attrs:{id:\"课件\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#课件\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 课件\")]),a(\"h3\",{attrs:{id:\"初级\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#初级\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 初级\")]),a(\"p\",[t._v(\"0 问： 什么是关键字，保留字\")]),a(\"p\",[t._v(\"答案：略\")]),a(\"p\",[t._v(\"1问： JavaScript中有几种基本类型？\")]),a(\"p\",[t._v(\"答案：\")]),a(\"ul\",[a(\"li\",[t._v(\"Undefined\")]),a(\"li\",[t._v(\"Null\")]),a(\"li\",[t._v(\"Boolean\")]),a(\"li\",[t._v(\"Number\")]),a(\"li\",[t._v(\"String\")]),a(\"li\",[t._v(\"Symbol （ESMAScript6新加的一种基本类型， 表示独一无二的值）\")])]),a(\"p\",[t._v(\"Function和Object是引用类型。\")]),a(\"p\",[t._v(\"基本类型和引用类型的区别是什么？\")]),a(\"p\",[t._v(\"基本类型是存放在栈内存的, 栈内存的一个特点， 是大小固定。\")]),a(\"p\",[t._v(\"而对象的属性是可以不断添加的， 所占用的内存大小也会随之改变， 因此数据不能直接存在栈内存中。而是存放在堆内存中， 而栈内存所保存的是一个指向该堆内存的地址。\")]),a(\"p\",[a(\"img\",{attrs:{src:\"https://pic3.zhimg.com/50/v2-dbf47419e58a8e8c73ed102376aac77e_hd.jpg\",alt:\"https://pic3.zhimg.com/50/v2-dbf47419e58a8e8c73ed102376aac77e_hd.jpg\"}})]),a(\"p\",[t._v(\"2 问： 什么是声明提升？这两个代码块，为什么前者不报错，后者报错？并写出第一个代码块的等价形式\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"console.log(a)\\nvar a = '123'\\n\")])]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"console.log(a)\\n\")])]),a(\"p\",[t._v(\"答案：\")]),a(\"p\",[t._v(\"第一个代码块 因为var关键字具有“声明提升”的作用， 会直接提升到作用域的顶部，因此代码等价于\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"var a\\nconsole.log(a)\\na = '123'\\n\")])]),a(\"p\",[t._v(\"另外用function声明的函数也具有同样的声明提升作用。\")]),a(\"p\",[t._v(\"第二个代码块因为a没有声明， 当然报错了\")]),a(\"p\",[t._v(\"3 问：什么是引用类型/对象？ 并根据以下代码阐述引用类型和基本类型的区别在哪里？\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-javascript\"}},[a(\"code\",[a(\"span\",{attrs:{class:\"token comment\"}},[t._v(\"// 为什么上方代码中b的数值还是llp， 下方代码中b的数值是kjj？\")]),t._v(\"\\n\"),a(\"span\",{attrs:{class:\"token keyword\"}},[t._v(\"var\")]),t._v(\" a \"),a(\"span\",{attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{attrs:{class:\"token string\"}},[t._v(\"'llp'\")]),t._v(\"\\n\"),a(\"span\",{attrs:{class:\"token keyword\"}},[t._v(\"var\")]),t._v(\" b \"),a(\"span\",{attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" a\\na \"),a(\"span\",{attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{attrs:{class:\"token string\"}},[t._v(\"'kjj'\")]),t._v(\"\\nconsole\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\".\")]),a(\"span\",{attrs:{class:\"token function\"}},[t._v(\"log\")]),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"b\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\"),a(\"span\",{attrs:{class:\"token comment\"}},[t._v(\"//output llp\")]),t._v(\"\\n\\n\"),a(\"span\",{attrs:{class:\"token comment\"}},[t._v(\"//----------------------------\")]),t._v(\"\\n\"),a(\"span\",{attrs:{class:\"token keyword\"}},[t._v(\"var\")]),t._v(\" a \"),a(\"span\",{attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    name\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\" \"),a(\"span\",{attrs:{class:\"token string\"}},[t._v(\"'llp'\")]),t._v(\"\\n\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\"),a(\"span\",{attrs:{class:\"token keyword\"}},[t._v(\"var\")]),t._v(\" b \"),a(\"span\",{attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" a\\na\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"name \"),a(\"span\",{attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{attrs:{class:\"token string\"}},[t._v(\"'kjj'\")]),t._v(\"\\nconsole\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\".\")]),a(\"span\",{attrs:{class:\"token function\"}},[t._v(\"log\")]),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"b\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\"),a(\"span\",{attrs:{class:\"token comment\"}},[t._v(\"//output \")]),t._v(\"\\n\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n\\tname\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\" \"),a(\"span\",{attrs:{class:\"token string\"}},[t._v(\"'kjj'\")]),t._v(\"\\n\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\")])]),a(\"p\",[t._v(\"//顺带一提JavaScript是不需要写分号的\")]),a(\"p\",[t._v(\"提示： 栈 堆\")]),a(\"p\",[t._v(\"答案：\")]),a(\"p\",[t._v(\"无论是基本类型还是引用类型， 当使用赋值操作的时候， 传递的都是栈内存中保存的值。\")]),a(\"p\",[t._v(\"因此，上一个代码块中， a和b开始都保存着一样的且独立的值'llp'， 然后改变了变量a的值为'kjj'， 当然不会影响b。\")]),a(\"p\",[t._v(\"而在第二个代码块中， 因为变量a是引用类型，当执行b = a操作的时候， 实际上是把变量a在栈内存中指向堆内存的地址赋值给了b。因此，a和b变量的栈内存中保存着相同的地址， 都指向同一片堆内存区域。而当我们执行a.name的时候，改变了这边堆内存， 因此，输出变量b的时候， 也是显示改变后的值。\")]),a(\"p\",[t._v(\"4 问： 为什么两次输出的值不同？\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-javascript\"}},[a(\"code\",[a(\"span\",{attrs:{class:\"token keyword\"}},[t._v(\"var\")]),t._v(\" age \"),a(\"span\",{attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{attrs:{class:\"token string\"}},[t._v(\"'12'\")]),t._v(\"\\n\"),a(\"span\",{attrs:{class:\"token keyword\"}},[t._v(\"var\")]),t._v(\" people \"),a(\"span\",{attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    name\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\" \"),a(\"span\",{attrs:{class:\"token string\"}},[t._v(\"'llp'\")]),t._v(\"\\n\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\"),a(\"span\",{attrs:{class:\"token keyword\"}},[t._v(\"function\")]),t._v(\" \"),a(\"span\",{attrs:{class:\"token function\"}},[t._v(\"Hello\")]),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"num\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" obj\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n\\tnum \"),a(\"span\",{attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{attrs:{class:\"token string\"}},[t._v(\"'18'\")]),t._v(\"\\n\\tobj\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"name \"),a(\"span\",{attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{attrs:{class:\"token string\"}},[t._v(\"'kjj'\")]),t._v(\"\\n    console\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\".\")]),a(\"span\",{attrs:{class:\"token function\"}},[t._v(\"log\")]),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"num\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" obj\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\"),a(\"span\",{attrs:{class:\"token function\"}},[t._v(\"Hello\")]),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"age\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" people\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\nconsole\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\".\")]),a(\"span\",{attrs:{class:\"token function\"}},[t._v(\"log\")]),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"age\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" people\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\")])]),a(\"p\",[t._v(\"在这之前我们先聊一下函数。\")]),a(\"p\",[t._v(\"与数学中的函数一样， 编程语言的函数有多个自变量/输入， 一个因变量/输出。\")]),a(\"p\",[t._v(\"另外， 函数可以用来封装重复的代码， 增加效率。\")]),a(\"p\",[t._v(\"声明函数的结构类似如下\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"function A(a, b) {\\n\\t\\n}\\n\")])]),a(\"p\",[t._v(\"调用方法如下\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"A(c, d)\\n\")])]),a(\"p\",[t._v(\"首先要声明的一点是， 函数内部是个块级作用域。什么意思呢？\")]),a(\"p\",[t._v(\"比如，我们可以\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"var a = 'llp'\\nfunction A() {\\n\\tvar a = 'kjj'\\n}\\n\")])]),a(\"p\",[t._v(\"我们在函数外面声明了一个变量a， 函数内部也声明了一个a， 这是没有任何影响的， 也就是说， 函数内部和外部是两个不同的作用域（即函数内部是个块级作用域）\")]),a(\"p\",[t._v(\"回到函数的声明， 函数接受两个参数a和b， 这两个参数叫做形式参数。形式参数是在函数内部的， 当调用函数的时候， 会把实际参数的值赋给函数内部的形式参数。\")]),a(\"p\",[t._v(\"比如\")]),a(\"p\",[t._v(\"当调用A(c, d)的时候， 会把变量c和d的值赋给函数内部的形式参数。\")]),a(\"p\",[t._v(\"最后， 当函数调用完毕的时候， 函数内部的变量会被销毁（也就是JS的内存回收）（当然也包括形参）。（也有例外， 那就是闭包\")]),a(\"p\",[t._v(\"另外普通的函数内部有两个特殊的值，arguments和this， argument是个类似数组的对象， 当执行函数的时候， 会把形式参数分别push到这个参数里。如，我们可以用arguments[0]和arguments[1]来获取函数内的第一个和第二个形式参数。\")]),a(\"p\",[t._v(\"那什么是this？\")]),a(\"p\",[t._v(\"this是函数内部的值\")]),a(\"p\",[t._v(\"函数调用的时候， 除了会显式的接受参数（也就是实际参数）， 也有隐式参数，这个参数根据如何调用来获取。\")]),a(\"p\",[t._v(\"比如当调用a.sayTo(b)的时候， 除了实际参数b会传递给函数内部的形式参数， 还会把变量a传递给函数内部的this。\")]),a(\"p\",[t._v(\"那可不可以手动传递值给函数内的this？\")]),a(\"p\",[t._v(\"当然可以。\")]),a(\"p\",[t._v(\"我们有call、apply、bind三个方法绑定this。\")]),a(\"p\",[t._v(\"比如上面的函数a.sayTo(b)， 会把a传递给函数sayTo内部的this， 如果想把this给个变量c的值，可以像这么做\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"a.sayTo.call(c, b)\\n或者\\na.sayTo.apply(c, [b])\\n\")])]),a(\"p\",[t._v(\"可以看到call和apply的作用是相同的， 不过是实际参数的传递方式不同而已。\")]),a(\"p\",[t._v(\"而bind却有点不同\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"var a = {\\n  \\n}\\nfunction A() {\\n\\t\\n}\\nvar b = A.bind(a)\\n\")])]),a(\"p\",[t._v(\"bind函数返回一个函数， 这个函数的this已经被绑定成a了。\")]),a(\"p\",[t._v(\"答案：\")]),a(\"p\",[t._v(\"调用函数的时候，实际参数和形式参数也是一个普通的赋值操作（即传递了栈内存中的值），而参数一个是基本类型， 一个是引用类型，因此，在函数内改变num的值不会影响函数外部的age， 而在函数内给obj增加属性， 会改变函数外部的people。\")]),a(\"p\",[t._v(\"3 问：ECMAScript 和 JavaScript的关系\")]),a(\"p\",[t._v(\"JavaScript是在浏览器执行的语言， 是因为它有BOM和DOM，前者提供了一些诸如window.open的函数， 后者提供了一些如document.querySelector的函数。 如果想让它在其他非浏览器平台运行的话， 肯定是不能有这两个的， 而JavaScript - BOM - DOM = ECMAScript。 比如Node平台， 内部的语言就是ECMAScript。 当然因为习惯， 即使我们在用Node的时候， 很多时候也是直接叫JavaScript而不是ES。\")]),a(\"p\",[t._v(\"BTW， 浏览器和Node的关系？V8引擎是用来解释JavaScript这门语言的。\")]),a(\"p\",[a(\"img\",{attrs:{src:\"http://upload-images.jianshu.io/upload_images/1224650-97528ea484b0f589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\",alt:\"\"}})]),a(\"h3\",{attrs:{id:\"中级\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#中级\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 中级\")]),a(\"p\",[t._v(\"1 JavaScript是没有类的概念的， 它是根据原型链来实现的， 但两者的作用其实是差不多的。\")]),a(\"p\",[t._v(\"那么请回答：什么是类和对象？说出你的理解\")]),a(\"p\",[t._v(\"For example。\")]),a(\"p\",[t._v(\"苹果是一个类， 在超市中看到各种苹果， 都是苹果类的实例。\")]),a(\"p\",[t._v(\"这些实例继承了苹果类的一些属性， 比如颜色是红色， 吃起来是甜的。\")]),a(\"p\",[t._v(\"但每个苹果实例之间也有区别， 因为不可能所有水果实例都长一样。\")]),a(\"p\",[t._v(\"为什么程序中需要类和对象的概念？\")]),a(\"p\",[t._v(\"比如我们需要100个一样的对象， 难道我们要用循环来生成吗？\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"for (var i = 0; i <= 100; i++) {\\n\\tarr[i] = {\\n    \\tname: 'llp',\\n    \\tage: 20\\n\\t}\\n}\\n\")])]),a(\"p\",[t._v(\"如果这100个对象， 每一个之间都有点差别， 又如何循环？\")]),a(\"p\",[t._v(\"2\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-javascript\"}},[a(\"code\",[a(\"span\",{attrs:{class:\"token keyword\"}},[t._v(\"var\")]),t._v(\" obj \"),a(\"span\",{attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    name\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\" \"),a(\"span\",{attrs:{class:\"token string\"}},[t._v(\"'llp'\")]),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\"\\n    age\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\" \"),a(\"span\",{attrs:{class:\"token number\"}},[t._v(\"21\")]),t._v(\"\\n\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\nconsole\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\".\")]),a(\"span\",{attrs:{class:\"token function\"}},[t._v(\"log\")]),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"obj\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"toString\"),a(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\\n\")])]),a(\"p\",[t._v(\"如上代码，我们声明了对象obj，然后输出obj.toString这个函数名（注意toString后没有()， 所以这里不是调用函数， 而是获取对象的值）， 发现并没有报错，而是显示这是一个函数。\")]),a(\"p\",[t._v(\"但是我们明明没有给obj定义内部的函数啊， 这里的toString函数是从哪来的？//答案在下一问能找到\")]),a(\"p\",[t._v(\"答案：\")]),a(\"p\",[t._v(\"继承于Object.prototype\")]),a(\"p\",[t._v(\"2\")]),a(\"p\",[t._v(\"提示：\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"obj.__proto__ === Object.prototype\\n\")])]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"var obj = {\\n    \\n}\\n//等价于\\nvar obj = new Object()\\n\")])]),a(\"p\",[t._v(\"这里的Object后有个()， 很明显我们知道Object是个函数，不信可以console一下\")]),a(\"p\",[t._v(\"我们知道，obj会继承Object.prototype这个对象的一些方法， 比如我们可以调用obj.toString函数。\")]),a(\"p\",[t._v(\"那么这里， Object函数和Object.prototype对象有什么关系呢？（不是问题， 我就逗逗你们）//我问了你们估计也不会\")]),a(\"p\",[t._v(\"但我们可以知道一点， 如果想生成一个对象， 需要一个函数A， 还有一个对象A.prototype， 就像生孩子那样:D\")]),a(\"p\",[t._v(\"而Object和Object.prototype这两个是浏览器自带的（天选之子）， 我们能猜到， 所有对象都是继承于Object.prototype。\")]),a(\"p\",[t._v(\"事实上， 当我们声明一个函数A， 会在后台自动创建对象A.prototype， 而我们上面说了， 只要有函数A， 还有一个对象A.prototype， 就能像生小孩那样，使用\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"var a = new A()\\n\")])]),a(\"p\",[t._v(\"这样的方法生成新的对象a\")]),a(\"p\",[t._v(\"显而易见， 对象a是继承于A.prototype的， 那么A.prototype这个自动生成的对象，又是从哪出来的呢？\")]),a(\"p\",[t._v(\"答案是： A.prototype 这个对象是Object和Object.prototype的产物， 当我们\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"function A() {\\n\\t\\n}\\n\")])]),a(\"p\",[t._v(\"的时候， 系统后台调用new Object()这样生成了对象A.prototype， 另外A.prototype这个函数会自带一个属性construcor，这个属性的值是函数A\")]),a(\"p\",[t._v(\"这时候，你可以console一下a，会发现一个链式结构的对象。\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"console.log(a)\\n//输出以下代码\\n{\\n    \\n\\t__proto__: {\\n        constructor: f A()\\n        __proto__: {\\n        \\ttoString: function() \\n        \\tvalueOf: function()\\n        \\t...\\n        \\t...\\n        }\\n\\t}\\n}\\n简化一下，就是(注意， 我标出了X和Y两个区域, 在X和Y区域中给定属性/函数， 就是实现继承的关键)\\na:\\n{\\n\\tX\\n\\t__proto__: A.prototype\\n}\\n\\nA.prototype:\\n{\\n\\tY\\n\\tconstructor: f A()\\n\\t__proto__: Object.prototype\\n}\\n\\nObject.prototype:\\n{\\n    toString: function() \\n    valueOf: function()\\n    ...\\n\\t...\\n}\\n\\na.__proto__ 指向对象 A.prototype\\nA.prototype.__proto__ 指向对象 Object.prototype\\n\")])]),a(\"p\",[t._v(\"这就是实现了继承，一切对象继承于Object.prototype。\")]),a(\"p\",[t._v(\"当我们查找属性的时候，现在当前对象中查找， 没有再查看\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"__proto__\\n\")])]),a(\"p\",[t._v(\"属性， 一层一层的查找， 也叫按原型链查找。\")]),a(\"p\",[t._v(\"不过这时候，a和A.prototype对象我们都没有给指定的值， 因此看不出继承的强大之处。\")]),a(\"p\",[t._v(\"那么现在我们需要让所有A类的实例都具有一个方法，很简单，当我们调用a.sayHi()的时候， 输出'hi'\")]),a(\"p\",[t._v(\"请输入你的代码\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"function A() {\\n    \\n}\\nA.prototype.sayHi = function () {\\n\\tconsole.log('hi')\\n}\\n\")])]),a(\"p\",[t._v(\"3\")]),a(\"p\",[t._v(\"我们有一个Apple类，如下\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"function Apple() {\\n\\t\\n}\\nApple.prototype.color = 'red'\\nApple.prototype.tasty = 'yummy'\\n\")])]),a(\"p\",[t._v(\"这样，所有Apple类的实例都继承了color和tasty值，但不是所有苹果都是一样的，现在，给Apple构造函数两个参数，分别是size和age， 生成实例的时候，根据传参的不同，所有实例的size和age不同\")]),a(\"p\",[a(\"strong\",[t._v(\"修改函数Apple来实现该功能\")])]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"function Apple(size, age) {\\n\\tthis.size = size\\n\\tthis.age = age\\n}\\n\")])]),a(\"p\",[t._v(\"4 new操作符的作用是什么？函数内部的this是什么？\")]),a(\"p\",[t._v(\"我们知道， 生成一个对象a， 需要一个函数A（又称构造函数），和对象A.prototype（又称对象A的原型对象），而具体的生成， 是通过调用new操作数，如\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"var a = new A()\\n\")])]),a(\"p\",[t._v(\"那么， 这里的new操作符是做了什么呢？\")]),a(\"p\",[t._v(\"另外，生成的实例的属性，要用到this关键字， 这个this是干嘛的？\")]),a(\"p\",[t._v(\"答案：\")]),a(\"p\",[t._v(\"new操作符的作用，可以分成四部\")]),a(\"ol\",[a(\"li\",[a(\"p\",[t._v(\"新建一个基于构造函数的原型对象的新对象。\")]),a(\"p\",[t._v(\"什么意思呢？\")]),a(\"p\",[t._v(\"比如这里， 构造函数A， 它的原型对象是A.prototype\")]),a(\"p\",[t._v(\"那么我们现在会先生成对象obj，如下\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"{\\n\\t__proto__: A.prototype\\n}\\n\")])])]),a(\"li\",[a(\"p\",[t._v(\"将生成的对象obj赋值给函数内部的this\")])]),a(\"li\",[a(\"p\",[t._v(\"执行构造函数\")])]),a(\"li\",[a(\"p\",[t._v(\"返回对象obj\")])])]),a(\"p\",[t._v(\"知道了new操作符如何工作后， 我们可以回到这个函数， 是不是就没问题了？\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"function Apple(size, age) {\\n\\tthis.size = size\\n\\tthis.age = age\\n}\\n\")])]),a(\"p\",[t._v(\"5 你知道吗？ 函数也是对象哦\")]),a(\"p\",[t._v(\"请写出，当我们声明\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"function A() {\\n    \\n}\\n\")])]),a(\"p\",[t._v(\"的时候， 在浏览器背后发生了什么\")]),a(\"p\",[t._v(\"答案：\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"var A = new Function()\\n\")])]),a(\"p\",[t._v(\"可以看到， 函数A一样是用new方法生成的， 它继承了Function.prototype\")]),a(\"p\",[a(\"img\",{attrs:{src:\"https://pic1.zhimg.com/v2-3688036266a94186b54081c3754f660c_b.png\",alt:\"\"}})]),a(\"p\",[t._v(\"那么， 一切都清楚了。\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"function A() {\\n\\t\\n}\\n\")])]),a(\"p\",[t._v(\"当我们声明一个函数的时候， 是通过new操作符继承了Function.prototype\")]),a(\"p\",[t._v(\"并且同时根据new操作符生成A.prototype， 这个A.prototype是继承了Object.prototype的。\")]),a(\"p\",[t._v(\"6 什么是函数的重载， JS中有重载吗？\")]),a(\"p\",[t._v(\"答案：略\")]),a(\"p\",[t._v(\"7 你知道什么是词法/静态作用域，什么是动态作用域吗？以及JavaScript使用的是哪种？\")]),a(\"p\",[t._v(\"答案：\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"var name = 'llp'\\nfunction static () {\\nconsole.log(name)\\n}\\n\\n(function(){\\nvar name = 'kjj'\\nstatic()\\n})()\\n\\n\")])]),a(\"p\",[t._v(\"8 以下代码输出什么？\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"var color = 'blue'\\n\\nfunction getColor() {\\n\\tvar color = 'red'\\n\\treturn color\\n}\\ngetColor()\\n\")])]),a(\"p\",[t._v(\"答案：\")]),a(\"p\",[t._v(\"red\")]),a(\"p\",[t._v(\"9 什么是闭包?\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"function A() {\\n\\tvar name = 'llp' \\n\\treturn function () {\\n        var people = {\\n            name: name \\n        }\\n        console.log(people)\\n\\t}\\n}\\n\\nvar a = A()\\na()\\n//输出\\n{name: 'llp'}\\n\")])]),a(\"p\",[t._v(\"闭包的官方定义是有权访问另一个函数作用域中变量的函数（上一个的答案:D）\")]),a(\"p\",[t._v(\"观察以上代码\")]),a(\"p\",[t._v(\"我们开始说过， 函数内部的变量会通过JavaScript自带的垃圾回收机制在函数调用后销毁， 但A函数内部的name并没有被销毁，这是因为有其他的东西使用到了这个变量， 所以这个值不会被销毁。\")]),a(\"p\",[t._v(\"本题不设题目。\")]),a(\"p\",[t._v(\"10 写出静态类型和动态类型的区别，强类型和弱类型的区别\")]),a(\"p\",[t._v(\"答案：\")]),a(\"p\",[t._v(\"静态类型：编译的时候就知道每一个变量的类型，因为类型错误而不能做的事情是语法错误。\")]),a(\"p\",[t._v(\"比如C和Java中， 声明变量的时候必须显式的指定变量的类型。\")]),a(\"p\",[t._v(\"动态类型：编译的时候不知道每一个变量的类型，因为类型错误而不能做的事情是运行时错误。譬如说你不能对一个数字a写a[10]当数组用。\")]),a(\"p\",[t._v(\"比如JS中无论何种类型都是用var声明。\")]),a(\"p\",[t._v(\"强类型：偏向于不容忍隐式类型转换。\")]),a(\"p\",[t._v(\"弱类型：偏向于容忍隐式类型转换。\")]),a(\"p\",[t._v(\"11 什么是对象属性（property）的特性（attribute）？数据属性和访问器属性的区别？\")]),a(\"p\",[t._v(\"特性就是描述了属性的各种特征， 特性是为了实现JS引擎用的，是内部值，所以下面用方括号圈出。\")]),a(\"p\",[t._v(\"访问器属性先不提， 先说数据属性。 我们目前用的大多是数据属性。\")]),a(\"p\",[t._v(\"比如\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"var people = {\\n\\tname: 'llp',\\n\\tage: 20,\\n\\tsayHi: function () {\\n        console.log('hi')\\n\\t}\\n}\\n\")])]),a(\"p\",[t._v(\"这里的name，age，sayHi都是数据属性。\")]),a(\"p\",[t._v(\"数据属性有四种特性\")]),a(\"p\",[t._v(\"[[Configurable]] 默认值为true。表示能否通过delete删除属性从而重新定义属性， 能否修改属性的特性， 或者能否把属性修改为访问器属性。\")]),a(\"p\",[t._v(\"[[Enumerable]] 默认值为true。 表示能否通过for-in循环返回属性。\")]),a(\"p\",[t._v(\"[[Writable]] 默认为true。表示能否修改属性的值。\")]),a(\"p\",[t._v(\"[[Value]] 默认为undefined。表示属性的值。读取属性值的时候，从这里读取。写入属性值的时候，从这里修改。\")]),a(\"p\",[t._v(\"如何修改一个属性的特性？\")]),a(\"p\",[t._v(\"使用Object.defineProperty函数\")]),a(\"p\",[t._v(\"如\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"var people = {\\n\\tname = 'kjj'\\n}\\nObject.defineProperty(people, 'kjj', {\\n\\tenumerable: false,\\n\\twritable: false,\\n\\tvalue: 'llp'\\n})\\n\")])]),a(\"p\",[t._v(\"这是修改一个已经存在的属性的特性。\")]),a(\"p\",[t._v(\"我们也可以用这个函数来新建属性\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"var people = {\\n}\\nObject.defineProperty(people, 'kjj', {\\n\\tenumerable: false,\\n\\twritable: false,\\n\\tvalue: 'llp'\\n})\\n\")])]),a(\"p\",[t._v(\"值得注意的是，当用这个函数来新建属性的时候，configurable、enumerable、writable特性的默认值都是false。\")]),a(\"p\",[t._v(\"一些额外的补充：\")]),a(\"p\",[t._v(\"在JavaScript中，有一个全局对象。在浏览器平台是window， 在Node平台是global。\")]),a(\"p\",[t._v(\"而当我们用var声明变量a的时候，会自动把a变成对象window的属性，可以通过window.a来获取。这是JS设计上的一个缺陷/糟粕。\")]),a(\"p\",[t._v(\"不过直接用var a = 'llp'和window.a = 'llp'也是有不同的。\")]),a(\"p\",[t._v(\"两者都是给了window对象一个a属性，但前者的a属性的Configurable特性是false， 也就是不能通过delete a来删除这个属性。 而后者的a属性的Configurable特性是true， 也就是可以通过delete a来删除这个属性。\")]),a(\"p\",[t._v(\"那么，什么是访问器属性呢？\")]),a(\"p\",[t._v(\"我们先看访问器属性的特性有哪些\")]),a(\"p\",[t._v(\"[[Configurable]]\")]),a(\"p\",[t._v(\"[[Enumerable]]\")]),a(\"p\",[t._v(\"这两个和数据属性都是一样的。\")]),a(\"p\",[t._v(\"[[Get]]\")]),a(\"p\",[t._v(\"[[Set]]\")]),a(\"p\",[t._v(\"我们可以直接上例子\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"var people = {\\n\\thisName: 'llp'\\n}\\nObject.defineProperty(people, 'name', {\\n\\tget: function () {\\n    \\treturn this.hisName//这个this指代的是people对象\\n\\t},\\n\\tset: function (newValue) {\\n    \\tthis.hisName = newValue\\n\\t}\\n})\\n\\n\")])]),a(\"p\",[t._v(\"当我们需要读取people.name的时候， 调用这个get方法。\\n当我们需要设置（比如赋值）people.name的时候， 会调用set方法。\\n而你想赋的值就会传递给set方法的形参newValue。\\n可以看出访问器属性和普通属性明显不同\")]),a(\"p\",[t._v(\"如何读取属性的特性？\")]),a(\"p\",[t._v(\"Object.getOwnPropertyDescriptor\")]),a(\"p\",[t._v(\"13 实际操作一下。\")]),a(\"p\",[t._v(\"我们需要一个Redrock类.实例是红岩人\")]),a(\"p\",[t._v(\"每个红岩人都有个自己的名字name\")]),a(\"p\",[t._v(\"所有红岩人都要有两个方法\")]),a(\"ul\",[a(\"li\",[t._v(\"isCool， 返回true\")]),a(\"li\",[t._v(\"getName， 返回name\")])]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"function Redrock(name) {\\n\\tthis.name = name\\n}\\nRedrock.prototype.isCool = function () {\\n\\treturn true\\n}\\nRedrock.prototype.getName = function () {\\n\\treturn this.name\\n}\\n\\n//test\\nvar llp = new Redrock('llp')\\nllp.getName()//llp\\nllp.isCool()//true\\n\")])]),a(\"p\",[t._v(\"现在我们增加需求， 给Redrock两个子类Web、Mobile。\")]),a(\"p\",[t._v(\"子类需要方法\")]),a(\"ul\",[a(\"li\",[t._v(\"getDpm 返回部门名\")])]),a(\"p\",[t._v(\"子类的实例需要有掌握的编程语言lang\")]),a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"function Web (name,  arr) {\\n\\tRedrock.call(this, name)\\n\\t//每个web类的实例和每个redrock都具有一些特有的性质， 所以我们直接在这里调用一次Redrock的构造函数\\n\\t//这句话的意思是，把当前函数的this传递给Redrock函数的this来执行。\\n\\tthis.lang = arr\\n}\\nWeb.prototype.getDpm = function () {\\n\\tconsole.log('we are web')\\n}\\nWeb.prototype.__proto__ = Redrock.prototype\\n\")])]),a(\"p\",[t._v(\"mobile也是同理\")]),a(\"p\",[t._v(\"恭喜你，如果上面的你都会，你就已经入门了JavaScript这门十天被写出来的语言！\")]),a(\"h3\",{attrs:{id:\"补充\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#补充\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 补充\")]),a(\"p\",[t._v(\"1 物理像素和CSS像素的差别？\")]),a(\"p\",[a(\"strong\",[t._v(\"设备像素/物理像素（device pixel）\")]),t._v(\"。电子显示屏都有\"),a(\"strong\",[t._v(\"分辨率\")]),t._v(\"一说，那么什么是分辨率？举个例子，我的电脑是1920 x 1080 的分辨率，这意味着一个横为1920个物理像素，高为1080个物理像素的矩形显示屏。\")]),a(\"p\",[a(\"strong\",[t._v(\"设备独立像素/密度无关像素（此处具体为css像素）\")]),t._v(\"。一种抽象的概念，如css中margin: 20px，这里的20px就是css像素，而开发者经常会对css像素感到迷茫，首先是因为css像素是相对单位，和厘米分米这些绝对单位是不同的，没有一个具体的大小。\")]),a(\"p\",[t._v(\"2 什么是DPR？\")]),a(\"p\",[a(\"strong\",[t._v(\"设备像素比（device pixel ratio）是设备像素和css像素数量的比值\")]),t._v(\"，我们知道设备像素是定值，所以DPR实际上是和css像素数量挂钩的。电脑缩放程度为100%的时候，DPR为1，因为缩放会影响css像素数量，所以也会影响DPR的大小。而手机缩放程度100%时DPR一般为2或3，一般手机都是不允许缩放的。\")])])}],!1,null,null,null);n.default=p.exports}}]);","extractedComments":[]}