本地git仓库  ======》》》》》》》》      remote git 仓库



git remote add <origin>

可以链接仓库，没有权限设置。

但如果想要push的话，需要目标仓库的登陆密码。



而git config 的作用并不是当作这个登陆的密码。

而是当你能push后，在commit记录上显示的人。

好处显而易见。





盒模型

content => padding => border => margin



background的一些属性， 和盒模型也有关系

background-clip 默认为border-box 主要是为background-color服务

background-origin 默认为padding-box 主要是为了background-image服务

background-attachment 也是个有趣的属性 设置为fixed



box-sizing  默认为content-box 。

当设置为border-box， width = content + padding + border



所有元素都是在父级元素的content下放置。 



然后元素又分块级元素 行内元素 inline-block



另外 元素可以设置为绝对定位（自动把display 设置成block）

如果不加top/left， 元素虽然是绝对定位， 此时的位置和正常布局还是放在一个的。

但如果把top改成0， 会发现是相对于某元素的padding-box 进行布局。



如果内部元素大于父元素的content， 就是溢出来了

overflow hidden / scroll

滚动条是放在padding以内的

document.documentElement.scrollTop = 0

= 

outer.scrollHeight - outer.clientHeight



块级元素 行内元素 inline-block

块级元素

元素有宽高， 默认占据父元素的100%。如果设定宽度 < 100%， 会被某种东西填充。。

inline-block

元素有宽高， 默认大小是自身的大小

inline元素

元素无法设定宽高， 默认大小是自身的大小



















//ghost theme

{{meta_title}}

{{body_class}}



{{@blog.logo}}

{{@blog.url}}

{{@blog.title}}

{{@blog.description}}

{{@blog.twitter}}

{{@blog.facebook}}



{{#foreach posts}}

​	{{#post}}

​		{{post_class}}

​		{{title}}

​		{{feature_image}}

​		{{content}}

​		{{date}}

​		{{#primary_tag}}

​			{{url}}

​			{{name}}

​		{{/primary_tag}}

​		{{#author}}

​			{{name}}

​			{{profile_image}}

​			{{bio}}

​			{{location}}

​			{{website}}

​		{{/author}}

​	{{/post}}

{{/foreach}}







output 

​	path

​	publicPath

npm run dev， 根据publicPath构建文件， 并提供静态资源访问

npm run build， 根据path构建文件， 根据publicPath构建依赖关系（比如图片资源的链接）





viewport如何计算？

根据

1.浏览器的设备像素宽高

2.缩放比



缩放比为1时，css像素大小=== 设备像素大小

为2时， css大小为设备像素大小两倍。



推出 viewport公式为：

浏览器的设备像素/缩放比



























CPU

 	

架构：

X86（32位），X86-64（64位，又叫X64）。使用CISC（复杂指令集）

ARM架构， 使用RISC指令集（精简指令集）

MISP架构



高级语言最后都是编译成机器码，也就是单纯的二进制。以C语言举例， 先是编译成汇编，再汇编成机器码。以前有人用汇编写程序，是因为用机器码写太难记了，所以汇编很大程度上只是一个对应关系/速记。



指令是在执行阶段发挥作用的，由CPU（Intel、AMD等）来执行。

伪指令是在编译阶段发挥作用的，由汇编器（MASM、TASM等）来解释。



而二进制机器码最终都是交给CPU来处理的，也就是CPU的指令集，因此相同的机器码/汇编在不同指令集的CPU上是行不通的。因此也有了所谓的X86汇编/ARM汇编。



CPU就是一块数字电路，用来处理二进制数据。内部有寄存器（存储数据）等元件。

CPU不能直接访问硬盘，只能访问内存。



前面提到了32位和64位的CPU，二者有很多区别。

这里的位数就是数据总线的数量

其中一个，顾名思义，32位CPU处理32位的数据，64位CPU处理64位的数据，怎么理解呢？

举个例子，32位CPU只能利用4G的内存，为啥？

首先4G = 2^32的字节

内存中有内存地址这一概念，也就是一个字节对应一个地址。（如C语言中的指针就是存放着内存地址。

CPU和内存进行交互，是根据内存地址来的，而一个CPU能访问多少内存地址呢？得看它的位数，因为32位，只能一次处理32位的二进制，2^32也就是4G的内存地址的数量（注意4G其实是2^32*8， 但因为一个地址是占一个字节的）



（数据的传送是靠总线完成，总线分地址总线，数据总线，指令总线。32位的CPU就是32根地址总线）

C语言中，随便输出一个指针变量，可能像这样 0x7fff5cc109d4  也就是2^48， 理论上64位是2^64次方， 不过反正也没那么大内存







存储器



主存/内存， 辅助存储器/硬盘等



ROM（只读存储器），RAM（随机读取存储器）属于主存。



RAM断电后数据会清楚，ROM不会。

BIOS在ROM上，电脑开机后，启动ROM上的BIOS，进行自检，启动引导程序







C语言编译后形成的可执行文件（二进制），只能在一个平台上运行，所以针对不同平台需要编译多次。



Java号称一次编写，到处运行。

Java编译后，生成的是一个叫字节码的中间码，而当在平台上运行的时候，会由JVM将字节码转成机器码。



JVM Java虚拟机，将字节码转化成机器码

JRE java运行环境

JDK java开发环境，能进行java的编译

JRE和JDK里都有JVM



JVM 

java虚拟机，虚拟化出了处理器，寄存器等。因此具有指令系统，JVM接收Java字节码（JVM字节码），因此不用管具体的平台是什么（不管是X86/ARM），因为实际上是在这个虚拟机上执行。



JRE Java的运行环境，内含JVM。

JDK Java开发工具，可以进行java代码的编译。







后端

提供API

提供页面入口URI

提供静态资源访问



前端

本地开发， 用webpackServer，代理请求API



后端入口URI /entry

API入口 /api/xxx

静态资源 /static/xxx











vue-cookie

this.$cookie.get()无法获取cookie， 发现是那个cookie默认开启的httpOnly: true， 所以无法获取

ctx.cookies.set()中的options里改成false就行了。



```
<a href='' download=''></a>
```

download属性的值是下载的文件名

具体的下载内容取决于href





post数据是二进制数据的时候， 在devtool中是看不到post实体数据的(formdata除外)



我们可以

直接post纯文本，本质是经过编码成二进制

直接post blob（如new Blob['']）或者file， 本质是直接写入二进制



也可以用FormData，这时候会自动设置请求头multipart，并且设置boundary。

后端要根据这个来解析实体。



当时候reader.readAsArrayBuffer的时候，我们可以

```
reader.readAsArrayBuffer(file)
axios({
    method: 'post',
    url: '/submit',
    data: reader.result
})
似乎等价于
axios({
    method: 'post',
    url: '/submit',
    data: file
})

```



ctx.request.body.files.file

是个File对象。

但直接fs.writeFile()后显示不了图片。

用fs读取文件后，看到Buffer是个很短的数

```
<Buffer 5b 6f 62 6a 65 63 74 20 4f 62 6a 65 63 74 5d>
```



如何解决？

能不能ctx.request.body.files.file 直接返回Buffer？

或者能不能把File转化成Buffer









```
[{id, usr}, {id,usr}]
想改动的话，必须进行遍历，来判断id，从而改变id

{
	id: {
      id,
      usr,
	},
}
```







当我们点击一个dom元素的时候。其实是这样的。

从window一直走到dom，每个元素都有个点击事件（捕获）。

之后从dom又走回冒泡。也叫冒泡。

因此每种事件都有一个flag， 可以是捕获也可以是冒泡



 